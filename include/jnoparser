// C++ code
//  Project: JNO (Just Object Node) for effective structuring data. Save and Load for view. Analog JSON
//  author: badcast <lmecomposer@gmail.com>
//  github: github.com/badcast/just-parser
//  soundcloud: soundcloud.com/light-mister

#pragma once

#include <cstdint>
#include <map>
#include <cstring>
#include <vector>
#include <fstream>
#include <stdexcept>

namespace jno {
class jno_object_parser;
class jno_object_node;

/// undefined type
typedef void* jvariant;
/// string type
typedef std::string jstring;
/// integer type
typedef std::int64_t jnumber;
/// real type
typedef double jreal;
/// logical type
typedef bool jbool;

using jstruct = std::map<int, jno_object_node>;

enum JNOSerializeFormat {
    // JNO (Just Node Object) a beautify string view
    JNOBeautify,
    // JNO (Just Node Object) a compact strting data for effective communication
    JNOCompact
};

enum JNOAllocationMethod {
    // dynamic type: dynamic deserialization fast and plump loading
    dynamic_allocation,
    // fixed type: memory saving, reloading by the "evaluation-conclusion"
    fixed_allocation
};

/* standart JNO types */
enum JNOType : std::uint8_t { Null = 255, Unknown = 0, JNOBoolean, JNONumber, JNOReal, JNOString };

class jno_object_node {
    friend class jno_object_parser;

    jno_object_parser* owner;
    jvariant var = nullptr;

    jno_object_node(jno_object_parser* head, void* handle);

   public:
    // Property 'name' it is Node
    const jstring name() const;

    // Property 'type' for get type
    JNOType type();

    // Property 'tree' for get child
    jno_object_node* tree(const jstring& child);

    // Property 'has_tree' defined tree
    jbool has_tree() const;

    // Property 'has_value' is the value from this Node
    jbool has_value() const;

    template <typename ValueTp>
    const ValueTp& value() const;

    /* operators */

    explicit operator jstring();
    explicit operator jnumber();
    explicit operator jreal();
    explicit operator jbool();
};

class jno_object_parser {
    friend class jno_object_node;

   protected:
    void* _storage;
    jstruct entry;

   public:
    jno_object_parser(JNOAllocationMethod allocationMethod = JNOAllocationMethod::dynamic_allocation);
    jno_object_parser(const jno_object_parser&) = delete;
    virtual ~jno_object_parser();

    void deserialize_from(const char* filename);
    void deserialize(const std::string& source);
    void deserialize(const char* source, int len);
    void deserialize(const std::string& content, int depth = -1);

    // Serialize as string format (text structured data)
    jstring serialize(JNOSerializeFormat format = JNOSerializeFormat::JNOCompact);

    // Find node from childrens
    // example, "First/Second/Triple" -> Node
    // for has a node, contains method use.
    jno_object_node* at(const std::string& name);

    // Find node
    jno_object_node* find_node(const std::string& nodePath);

    // search node by name or prefix value, example
    jno_object_node* search(const std::string& name);

    // result of occupied memory forevery nodes
    jnumber occupied_memory();

    jnumber occupied_memory(JNOType box);

    bool contains(const std::string& nodePath);

    jno_object_node* tree(const jstring& child);
};

jno_object_node& operator<<(jno_object_node&, const jstring&);

jno_object_node& operator<<(jno_object_parser&, const jstring&);

std::ostream& operator<<(std::ostream&, const jno_object_node&);

std::ostream& operator<<(std::ostream&, const jno_object_parser&);

}  // namespace jno
